# **코리아 IT 아카데미 앱개발**
## 자바수업정리

### 컴파일러 해석 방향
    위에서 아래로 좌에서 우로
    
                  기본 구조
                    	프로젝트
                    		패키지
                    			클래스(앞글자 대문자)
                                  				  메소드(이름 뒤에 소괄호)
                                  					                소스코드
                                                       
### 출력 메소드
```
1. print() : 마지막에 자동으로 줄바꿈되지 않고 아래 문장과 이어서 출력된다.
2. println() : 마지막에 자동으로 줄바꿈된다.
3. printf()
```

### 변수 : 저장공간
```
x			=		10
저장공간의		대입		값(상수)
이름			연산자
```

### 자료형(type)
```
자료형	type		byte	값	

정수형	int		4	1, 325, 54754, -321839, ...
실수형	float		4	1.0F, 0.0F, 156.156F, -456.1596F, ...
	double		8	1.0, 0.0, 156.156, -456.1596, ...
문자형	char		2	'A', '강', '0', ...	
문자열	String		?	"문우람", "ABC", "A", "0", "0.1", ...
```

### 변수의 선언
- 자료형 변수명 = 초기값; -> 초기화
- 자료형 변수명;
```
	예)
	int x = 10;
	x라는 이름의 저장공간(RAM=메모리)이 할당(allocation)되고 그 안에 10이 들어간다.
```

### 변수의 사용
```
int data = 10;			저장공간
data = 20;			저장공간
data + 9;			값
data = data + 99;		저장공간, 값
System.out.print(data);		값
```

### 변수 선언 시 주의사항
1. 같은 이름의 변수로 선언할 수 없다.
2. 초기화를 해준다.
3. 되도록 선언부에 한꺼번에 선언한다(영역 상단).

### 변수명 주의사항
- 문자로 시작해야 한다.
- 특수문자를 사용할 수 없다. 단. _허용한다.
- 소문자로 시작한다.
- 공백을 사용할 수 없다.
```
good_boy : 언더바 표기법
goodBoy : 카멜 표기법
```
- 되도록 한글은 사용하지 않는다.
- 명사로 사용한다.
- 뜻이 있는 단어를 사용한다.
```
a, b, c, d, e, .... (x)
data, number, age, name, ... (0)
```

### 변수를 사용하는 이유
1. 반복되는 값을 쉽게 관리하기 위해서
2. 의미 없는 값을 하나의 정보로 만들기 위해서(자료구조)

### 출력 메소드
- printf(): 서식 문자를 사용하여 출력할 수 있으며, 자동으로 줄바꿈되지 않는다.
  
### 상수
- 항상 그대로인 수.
- 값을 변경할 수 없도록 한다.	
```	
final 자료형 상수명 = 값;
```

### 형변환
```
- 자동 형변환
	정수 + 정수 = 정수
	정수 + 실수 = 실수
	3 + 0.0 = 3.0
	5 / 2 = 2	
	5/2.0 = 2.5	
	문자 + 정수 = 정수


- 강제 형변환
	(자료형)값;
	예) (double)3 = 3.0으로 취급된다.
```

### 문자열 형변환
1. 다른 자료형을 문자열로
	문자열과 다른 일반 자료형을 연결하면 결과는 문자열이 된다.

2. 문자열을 다른 자료형으로
	일반 자료형은 일반 자료형끼리만 형변혼이 가능하다.
	문자열 타입은 클래스 타입이므로, 일반 자료형의 클래스 타입의 도움을 받아야 한다.
```
Integer.parseInt("") => 문자열에서 변환된 정수 값
Float.parseFloat("") => 문자열에서 변환된 실수 값
Double.parseDouble("") => 문자열에서 변환된 실수 값
```

### 입력
- 커서가 깜빡이고 있는 상태.
- 입력하기 전에 출력을 통해 어떤 값을 입력해야할 지 사용자에게 알려주어야 한다.

### 입력 클래스
- Scanner sc = new Scanner(System.in);

### 입력 메소드
```
next() : 사용자가 입력한 문자열 값
	- 사용자가 입력한 값 중 공백 또는 줄바꿈 문자를 구분점으로 각 문자열을 분리한다.
	- 첫 번째 문자열은 첫 번째 next()에 담고
	  두 번째 문자열은 두 번째 next()에 담는다.

nextLine() : 사용자가 입력한 문자열 값
	- 공백 또는 줄바꿈 문자도 값으로 취급하기 때문에 그대로 입력받는다.
```

### 입력 클래스
- 기능이 있는 특수문자

### 연산자의 우선순위
**최**우선 연산자 <br>
**단**항 연산자 <br>
**산**술 연산자 <br>
**쉬**프트 연산자 <br>
**관**계 연산자 <br>
논**리** 연산자 <br>
**삼**항 연산자 <br>
**대**입 연산자

### 결합성
- 하나의 수식에 동일한 연산자가 여러 개 사용되면 알맞은 방향으로 결합되어 연산되는 성질

### 논리형(boolean)
```
참 : true
거짓 : false

boolean(1byte) = true, false
```

### 조건식

결과가 참 또는 거짓, 둘 중 하나가 나오는 식. <br>
참 또는 거짓 값.	<br>
예) boolean check = 10 == 11;
```
관계 연산자(2)
	==	: 같다
	!=	: 같지 않다
	>, <	: 초과, 미만
	>=, <=	: 이상, 이하
	
논리 연산자(3)
	&&(AND), A && B, 두 조건식 모두 참이면 참
	||(OR), A || B,	 둘 중 하나라도 참이면 참

단항 연산자(1)
	!(NOT), !A,  조건식이 참이면 거짓으로, 거짓이면 참으로 변경


삼항 연산자
	? :, 조건식 ? 참 : 거짓,  조건식이 참이면 참, 거짓이면 거짓
	예) int result = 10 > 11 ? 10 : 11;
```

### 삼항 연산자를 사용해야 할 때 
- 조건식이 딱 한 개 있을 때

### 제어문
```
-> if 문
	if(조건식) {
		실행할 무장;
	}
	if(조건식) {
		실행할 무장;
	}
	if(조건식) {
		실행할 무장;
	}...
	
	if(조건식) {
		실행할 무장
	}else if(조건식) {
		실행할 문장;
	}else {
		실행할 문장
	}
	
-> switch 문
	
	switch(변수명) {
	case 값1:
		실행할 문장;
		break;
	case 값2:
		실행할 문장;
		break;
	case 값3:
		실행할 문장;
		break;
	case 값4:
		실행할 문장;
		break;
	...
	default
	}
```

### 삼항 연산자, if문, switch문의 비교
- 삼항 연산자: 조건식이 1개 있을 경우 사용
- if문: 조건식에 비교(>, <, >=, <=) 연산자를 사용하거나, 여러 개의 조건식을 논리 연산자로 연결할 때 사용 
- switch문: 하나의 변수에 여러 개의 값이 담길 수 있고, 각 값이 같은 지를 비교할 때 사용

### 대입 연산자(복합 대입 연산자, 누적 연산자)
+=, -=, *=, /=, %=,...
```
int money = 10000;
// money = money - 1500;
money -= 1500;
System.out.println(money);

int data =10;
//data = data + 1;
//data += 1;
data++;
System.out.println(data);
```

### 증강 연산자
++, --
```
전위형: 해당 라인부터 바로 적용
	++data, --data

후위형: 다음 라인부터 적용
	data++, data--
```

## 반복문
### 종류
※ for 문
```
int i = 0; i < 10 i = i + 1
for(초기식; 조건식; 증감식) {
	실행할 문장;
}

	1. 초기식
	-------
	2. 조건식(true)
	3. 실행할 문장	
	4. 증감식
	5. 조건식(true)
	6. 실행할 문장
	7. 증감식
	8. 조건식(false)
```

※ while문 
- 몇번 반복할지 모를때
- 몇번 반복할지 알면 무조건 for문 써야된다.
```
while(조건식) {
	실행할 문장;
}
```

### for문과 while문의 차이
- for : 몇 번 반복할 지 알 때
- while: 몇번 반복할 지 모를 때

※ do ~ while문
```
do {
	실행할 문장;
} while(조건식);
```
무조건 한 번은 실행되어야 할 때 사용한다.

### 기타 제어문
```
break : 즉시 해당 중괄호 영역을 탈출한다.
	-if문 안에서 사용 시 if문을 탈출하지 않고 if문을 감싸고 있는 중괄호 영역을 탈출한다.

continue : 즉시 다음 반복.
	- 아래의 코드를 실행하지 않기 위해서 사용한다.
```

## 배열
- 저장공간의 나열
1. 변수를 여러 개 선언하면 이름도 여러 개 생긴다. 이 때 각 저장공간을 관리하기가 불편하다.
   따라서 n칸 배열을 한 번만 선언하면 저장공간도 n개 생기고, 이름도 한 개이기 때문에 관리하기 편하다.

2. 규칙성이 없는 값이 규칙성을 부여하기 위해서

### 배열의 선언
```
자료형[] 배열명 = {값1, 값2, ....};  ->  어떤 값을 넣을 지 알 때 사용
자료형[] 배열명 = new 자료형[칸수];  ->  어떤 값을 넣을 지는 모르나, 몇 칸 만들지는 알 때 사용
자료형[] 배열명 = null;  ->  어떤 값을 넣을지도 모르고 몇 칸 만들지도 모를 때 사용한다.

* new: Heap 메모리에 할당, 초기값으로 자동 초기화
* null: 주소의 초기값, 어떤 주소를 넣을 지 모를 때 작성하는 값
* 자바에서 배열은 항상 Heap(동적 메모리)에 할당되기 때문에 메모리 상으로는 동적배열만 존재한다.
```

### 배열의 구조
```
int[] arData = {3, 5, 1, 2, 8};
	
arData라는 이름의 저장공간은 한 개 만들어지며, 여기에는 한 개의 값만 담을 수 있다.
5개의 값을 담기 위해서는 5칸이 필요하며, 이는 Heap 메모리에 할당된다. 5칸의 저장공간 중
첫 번째 저장공간의 주소값이 arData 저장공간으로 들어가며, 다음 주소에 접근하기 위해서는
+ n을 한다. 예를 들어 arData + 2는 1이라는 값이 담긴 주소값이 되며,
*(arData + 2)는 해당 주소에 가서 읽어온 1이라는 값이 된다. JAVA에서는 직접 주소에 접근하는
연산자가 없기 때문에 위와 같은 식을 []로 치환하여 사용하며, arData[2]로 사용한다.
각각의 방 번호는 index라고 부르며, 배열은 시작주소를 가지고 있기 때문에 인덱스 번호는 항상 0부터 시작된다.
```

### length
배열을 선언하면 length라는 상수가 선언되고, 해당 배열의 길이가 담긴다. <br>
배열명.length로 사용하게 된다.

### 배열의 사용
```
int[] arData = new int[5]; -> 저장공간
arData[0] = 10;	-> 저장공간
arData[0] + 9; -> 값
System.out.println(arData); -> 주소값
arData[2] = arData[0] + arData[1]; -> 저장공간, 값
System.out.println(arData[5]); -> 값
```
- 배열을 같이 배울 때 문자열도 같이 공부하는게 좋다.

### 2차원 배열
배열 안에 배열 -> 잘 쓰지 않는다 ->메모리 효율이 좋지 않음 -> 이거말고 "클래스"를 쓴다.  -> 이차원배열은 "행"부터 접근하고 두번쨰는 "열"로 접근하자

### 4차원 배열
```
1차원 배열을 여러 개 선언할 때 관리하기 힘들기 때문에
 2차원 배열을 한 번 선언한다.

※ 2차원 배열부터는 메모리 낭비가 심하므로 선호하지 않는다.

2차원 배열 선언
자료형[][] 배열명 = {{값1, 값2, 값3,...}, {값4, 값5, 값6,...}};
자료형[][] 배열명 = new 자료형[행][열];
자료형[][] 배열명 = null;


int[][] arrData = new int[2][3];

□   		arrData      arrData.length(행의 길이)
□□   		arrData[행]   arrData[행].length(열의 길이)
□□□ □□□   	arrData[행][열]
```

## 메소드
- 이름 뒤에 소괄호
- 단, 키워드 뒤에서 소괄호가 메소드가 아니다.(if, switch ....)

### 매개변수
함수랑 함수를 연결해주는것 <br>
ex) 결혼 중매하는 분들
```
f	(x)     	= 	2x+1
메소드 이름  매개변수  		리턴값
```

### 메소드 선언
```
(1)리턴타입 (2)메소드명(자료형 (3)매개변수명, ...) {
	(4)실행할 문장;
	(5)return 리턴값;
}
```
1. 리턴 값이 있다면 리턴 값의 자료형을 작성하고, 리턴 값이 없다면 비워놓지 않고 void를 작성한다.
2. 동사로 작성한다(연필(매개변수)을 쓴다(메소드)). 
3. 외부에서 전달받을 값이 있다면, 자료형과 순서에 맞게 선언해준다. 
     생략 시, 외부에서 값을 전달받을 수 없게 된다. 
4. 생략이 가능하다. 메소드의 기능을 구현하는 로직을 작성한다. 
5. 생략이 가능하다. 리턴값이 있다면, 사용한 부분 통채로를 리턴값으로 봐야한다.

### 메소드 선언 순서
```
1. 메소드 이름을 생각한다.
	add(){}

2. 매개변수를 생각한다.
	add(int number1, int number2){}

3. 실행할 문장을 작성한다.
	add(int number1, int number2){
		int result = number1 + number2;	
}

4 . 리턴 값을 작성한다.
	add(int number1, int number2){
		int result = number1 + number2;
	return result;	
}

5. 리턴타입을 결정한다.
	int add(int number1, int number2){
	int result = number1 + number2;
	return result;	
}
```

### 메소드 주의사항
- 메소드를 선언할 때에는 {}(중괄호)가 있으며, 반드시 메소드 밖에서 선언한다.
- 메소드를 사용할 때에는 {}(중괄호)가 없으며, 반드시 메소드 안에서 사용한다.

### 메소드 목적
1. 재사용(특정성을 부여해서는 안된다).
2. 소스코드 간결화

## 클래스
- 공통요소를 한 번만 선언해놓고 가져다 사용만 하도록 설계한다.
1. 타입이다
	클래스 안에 선언된 변수와 메소드를 사용하고 싶다면,
	해당 클래스 타입으로 변수를 선언해야 한다.

2. 주어이다
	원숭이가 먹는다 바나나를 **Monkey.eat("banana");**

### 클래스 선언
```
class 클래스명 {
	필드(변수, 메소드)
}
```
